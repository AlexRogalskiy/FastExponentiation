<h3>Precision comparison test for specified exponent</h3>
Testing following power functions:
<br />
@for(int i = 0; i < Misc.PowerFunctionModels.Count; i++) {
    <div>"<b>@Misc.PowerFunctionModels[i].Name</b>"</div>
}
<br />
Parameters for precision test:
<br />
Exponent:
<br />
<NumberInput @ref="@ExpInput" DefaultValue="-0.5" PlaceHolder="Type exponent here" />
<br />
Minimum base:
<br />
<NumberInput @ref="@MinInput" DefaultValue="1" PlaceHolder="Type minimum base here" />
<br />
Maximum base:
<br />
<NumberInput @ref="@MaxInput" DefaultValue="100" PlaceHolder="Type maximum base here" />
<br />
Number of iterations:
<br />
<NumberInput @ref="@IterationsInput" DefaultValue="10000" PlaceHolder="Type iterations count here" />
<br />
<button @onclick="ComparePrecision">Compare precision</button>
<br />
y = x ^ Exponent

<RadzenChart>
    @foreach(var measureResult in MeasuresResults) {
        <RadzenLineSeries Smooth="false" Data="@measureResult.dataItems" CategoryProperty="Base" ValueProperty="Value" Title="@measureResult.powerFunctionModel.Name" />
    }
</RadzenChart>
<div class="container">
    @foreach(var measureResult in MeasuresResults) {
        <MeasureResultDisplay MeasuresResult="@measureResult" />
        <br />
    }
</div>

@code {
    private static int baselinePowerFunctionIndex = Misc.PowerFunctionModels.IndexOf(new Misc.PowerFunctionModel { Name = "Built-in power" });

    public NumberInput ExpInput;
    public NumberInput MinInput;
    public NumberInput MaxInput;
    public NumberInput IterationsInput;


    public const int DataCount = 200;

    public List< MeasuresResult> MeasuresResults = new List<MeasuresResult>();

    void ComparePrecision() {
        var exp = ExpInput.Value;
        var min = MinInput.Value;
        var max = MaxInput.Value;
        var step = Math.Abs(max - min) / IterationsInput.Value;
        var ignoreCount = (int)IterationsInput.Value / DataCount;

        var baselineFunction = Misc.PowerFunctionModels[baselinePowerFunctionIndex].Function;
        MeasuresResults = new List<MeasuresResult>();
        foreach(var powerFunctionModel in Misc.PowerFunctionModels) {
            var measureResult = new MeasuresResult(powerFunctionModel);
            var totalDifference = 0.0d;

            int i = 0;

            for(double v = MinInput.Value; v <= MaxInput.Value; v += step) {
                if(v == 0d) {
                    continue;
                }
                var baselineValue = baselineFunction(v, exp);
                var myValue = powerFunctionModel.Function(v, exp);

                var diff = Math.Abs(baselineValue / myValue);
                if(double.IsNaN(diff) || !double.IsFinite(diff) || double.IsNaN(baselineValue) || double.IsNaN(myValue) || !double.IsFinite(baselineValue) || !double.IsFinite(myValue)) {
                    continue;
                }
                if(i % ignoreCount == 0) {
                    measureResult.dataItems.Add(new DataItem { Base = v, Value = myValue });
                }
                var percentageDiff = FastMath.ToPercentage(diff);
                if(percentageDiff > measureResult.maxError) {
                    measureResult.maxErrorNumber = v;
                    measureResult.maxError = percentageDiff;
                }
                totalDifference += diff;
                i++;
            }
            measureResult.averageError = FastMath.ToPercentage(totalDifference / i);
            MeasuresResults.Add(measureResult);
        }
        Console.WriteLine("Done comparing precision for {0} numbers", MeasuresResults[baselinePowerFunctionIndex].dataItems.Count);
    }

    protected override void OnAfterRender(bool firstRender) {
        if(firstRender) {
            ComparePrecision();
            StateHasChanged();
        }
        base.OnAfterRender(firstRender);
    }
}