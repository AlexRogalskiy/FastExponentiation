<h3>Precision comparison test for specified exponent</h3>
Parameters for precision test:
<br />
Exponent:
<br />
<NumberInput @ref="@ExpInput" DefaultValue="-0.5" PlaceHolder="Type exponent here" />
<br />
Minimum base:
<br />
<NumberInput @ref="@MinInput" DefaultValue="1" PlaceHolder="Type minimum base here" />
<br />
Maximum base:
<br />
<NumberInput @ref="@MaxInput" DefaultValue="100" PlaceHolder="Type maximum base here" />
<br />
Number of iterations:
<br />
<NumberInput @ref="@IterationsInput" DefaultValue="10000" PlaceHolder="Type iterations count here" />
<br />
<button @onclick="ComparePrecision">Compare precision</button>
<br />
y = x ^ Exponent

<RadzenChart>
    <RadzenLineSeries Smooth="false" Data="@RealValues" CategoryProperty="Base" ValueProperty="Value" Title="Real values" />
    <RadzenLineSeries Smooth="false" Data="@ApproximateValues" CategoryProperty="Base" ValueProperty="Value" Title="Approximate values" />
    <RadzenLineSeries Smooth="false" Data="@HighestError" CategoryProperty="Base" ValueProperty="Value" Title="Highest error" Stroke="red">
        <RadzenMarkers MarkerType="MarkerType.Circle" />
    </RadzenLineSeries>
</RadzenChart>
<br />

Max error: <b>@(FormatError(maxError))</b>% for number <b>@maxErrorNumber</b>
<br />
Average error: <b>@(FormatError(averageError))</b>%

@code {
    NumberInput ExpInput;
    NumberInput MinInput;
    NumberInput MaxInput;
    NumberInput IterationsInput;

    public class DataItem {
        public double Value { get; set; }
        public double Base { get; set; }
    }

    public const int DataCount = 200;

    public List<DataItem> RealValues;
    public List<DataItem> ApproximateValues;
    public List<DataItem> HighestError;

    private double maxErrorNumber = 0;
    private double maxError = 0;
    private double averageError = 0;

    double ToPercentage(double ratio) {
        return Math.Abs(ratio - 1d) * 100d;
    }

    string FormatError(double error) {
        return String.Format("{0:0.00}", error);
    }

    void ComparePrecision() {
        var exp = ExpInput.Value;
        var min = MinInput.Value;
        var max = MaxInput.Value;
        var step = Math.Abs(max - min) / IterationsInput.Value;
        var ignoreCount = (int)IterationsInput.Value / DataCount;

        RealValues = new List<DataItem>();
        ApproximateValues = new List<DataItem>();

        maxError = double.MinValue;
        double totalDifference = 0;
        int i = 0;

        for(double v = MinInput.Value; v <= MaxInput.Value; v += step) {
            if(v == 0d) {
                continue;
            }
            var realValue = Math.Pow(v, exp);
            var approximateValue = FastMath.FastPower(v, exp);

            var diff = Math.Abs(realValue / approximateValue);
            if(double.IsNaN(diff) || !double.IsFinite(diff) || double.IsNaN(realValue) || double.IsNaN(approximateValue) || !double.IsFinite(realValue) || !double.IsFinite(approximateValue)) {
                continue;
            }
            if(i % ignoreCount == 0) {
                RealValues.Add(new DataItem { Base = v, Value = realValue });
                ApproximateValues.Add(new DataItem { Base = v, Value = approximateValue });
            }
            var percentageDiff = ToPercentage(diff);
            if(percentageDiff > maxError) {
                maxErrorNumber = v;
                maxError = percentageDiff;
                HighestError = new List<DataItem>() { new DataItem { Base = v, Value = realValue } };
            }
            totalDifference += diff;
            i++;
        }
        averageError = ToPercentage(totalDifference / i);
        Console.WriteLine("Done comparing precision for {0} numbers", RealValues.Count);
    }

    protected override void OnAfterRender(bool firstRender) {
        if(firstRender) {
            ComparePrecision();
            StateHasChanged();
        }
        base.OnAfterRender(firstRender);
    }
}